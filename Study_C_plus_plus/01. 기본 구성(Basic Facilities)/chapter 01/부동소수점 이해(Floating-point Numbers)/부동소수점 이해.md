# 🤔 자료형 개요

실수(rational number)를 표현할 때 부동소수점 자료형인 `float`과 `double`을 사용한다.
고정소수점으로 실수를 표현하는 것은 부동소수점에 비해 표현할 수 있는 범위에 제약이 많기 때문에 일반적인 프로그래밍 언어에서는 부동소수점 자료형만 지원합니다.
데이터베이스(예로 오라클의 NUMBER 자료형)의 경우 빠른 자료 처리를 위해 고정소수점의 형식을 지원합니다.
수치해석 용 프로그램들은 대부분 자체 자료형을 갖고 있고 숫자를 문자열 구조로 만들어 계산하여 수치 자료형의 한계를 극복합니다.

## 🧑🏻‍💻 부동소수점의 이해

C++에서 부동소수점은 실수를 표현하는 데 사용됩니다. 위에서 언급하였듯이 주로 `float`, `double`, `long double` 세 가지 형태의 부동소수점 자료형이 있습니다.  
부동소수점을 표현하는 방식은 IEEE 754 표준에 따라 이루어집니다. 하지만 부동소수점 연산은 정수 연산과는 다르게 부동소수점 에러가 발생할 수 있는데,  
이는 소수점 이하의 값들을 이진법으로 정확하게 표현할 수 없기 때문입니다. 부동소수점 연산에서 반올림 오차나 정밀도 손실 같은 문제가 발생할 수 있습니다.  
따라서 부동소수점을 비교할 때는 주의가 필요하며, `float`나 `double`의 정밀도에 맞게 적절한 처리가 필요합니다.

예를 들어, 부동소수점을 비교할 때는 두 값의 차이가 아주 작은지 확인하는 방법이 유용할 수 있습니다.  
또한, 부동소수점 연산에서 발생할 수 있는 오차를 최소화하기 위해 적절한 방법으로 값들을 비교하고 계산하는 것이 중요합니다.

## 📄 자료형 범위

1. char: 주로 1바이트로 표현되며, -128부터 127까지의 signed char 혹은 0부터 255까지의 unsigned char 값을 가질 수 있습니다.

2. int: 시스템에 따라 다를 수 있지만, 보통 4바이트(32비트) 또는 8바이트(64비트)로 표현되며, 대략적으로 -2,147,483,648부터 2,147,483,647까지의 signed int 값이 표현 가능합니다. unsigned int는 0부터 4,294,967,295까지의 값을 가질 수 있습니다.

3. short: 보통 2바이트로 표현되며, -32,768부터 32,767까지의 signed short 값이 표현 가능합니다. unsigned short는 0부터 65,535까지의 값을 가질 수 있습니다.

4. long: 시스템에 따라 다를 수 있지만, 4바이트(32비트)에서는 -2,147,483,648부터 2,147,483,647까지의 signed long 값을 가질 수 있고, 8바이트(64비트)에서는 -9,223,372,036,854,775,808부터 9,223,372,036,854,775,807까지의 signed long 값을 가질 수 있습니다. unsigned long은 0부터 4,294,967,295(32비트) 또는 18,446,744,073,709,551,615(64비트)까지의 값을 가질 수 있습니다.

5. long long: C++11 이후 도입되었으며, 보통 8바이트(64비트)로 표현됩니다. -9,223,372,036,854,775,808부터 9,223,372,036,854,775,807까지의 signed long long 값을 가질 수 있고, unsigned long long은 0부터 18,446,744,073,709,551,615까지의 값을 가질 수 있습니다.
